digraph PhpGraph {

rankdir=TB;

{  rank=same;
     vocabulary;
    "0" [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red", label="Short namespace\nClass name"];
    "1" [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow", label="Method name\nsignature"];
    "2" [fixedsize="1", width="2", height="2", shape="diamond", style="filled", color="cyan", label="Parameter\nindex"];
    "3" [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="a method\nImplementation"];
    "5" [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green", label="Short namespace\nInterface name"];
}

{  rank=same;
    inheritance;
    Daughter [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    Mother [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    "The class Daughter extends the class Mother" [shape=plaintext];
    Daughter -> Mother [label="extends"];
}

{ rank=same;
    implementing;
    Concrete [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    Contract [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green"];
    "The class Concrete implements the interface Contract" [shape=plaintext];
    Concrete -> Contract [label="implements"];
}

{ rank=same;
    extending;
    InterfaceB [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green"];
    InterfaceA [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green"];
    "The interface InterfaceB extends the interface InterfaceA" [shape=plaintext];
    InterfaceB -> InterfaceA [label="extends"];
}

{ rank=same;
    declaring1;
    Service [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    doSomething [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow"];
    "The class Service is the first declaring the method doSomething()" [shape=plaintext];
    Service -> doSomething [label="declares"];
}

{ rank=same;
    declaring2;
    Iterator [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green"];
    hasNext [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow"];
    "The interface Iterator is the first declaring the method hasNext()" [shape=plaintext];
    Iterator -> hasNext [label="declares"];
}

{ rank=same;
    owning1;
    Command [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    doRun [fixedsize="1", width="2", height="2", shape="rectangle", style="filled"];
    "The class Command is implementing the method doRun()" [shape=plaintext];
    Command -> doRun [label="owns"];
}

{ rank=same;
    owning2;
    doBind [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow"];
    bind2 [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="doBind"];
    "The declared method doBind() is also implementing it" [shape=plaintext];
    doBind -> bind2 [label="owns"];
}

{ rank=same;
    depend1;
    enterNode [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="Visitor\nenterNode"];
    Visitor [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    "The implementation Visitor::enterNode() \ndepends on the class Visitor" [shape=plaintext];
    enterNode -> Visitor [label="depends"];
}

{ rank=same;
    depend2;
    leaveNode [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="Visitor\nleaveNode"];
    Param0 [fixedsize="1", width="2", height="2", shape="diamond", style="filled", color="cyan", label="0"];
    "The implementation Visitor::leaveNode() \ndepends on parameter #0 of the method" [shape=plaintext];
    leaveNode -> Param0 [label="depends"];
}

{ rank=same;
    depend3;
    create [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="Factory\ncreate"];
    Document [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    "The implementation Factory::create() \ncreates a new instance of Document" [shape=plaintext];
    create -> Document [label="instantiates"];
}

{ rank=same;
    calling;
    facade [fixedsize="1", width="2", height="2", shape="rectangle", style="filled", label="Facade\ndoRun"];
    delegate [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow"];
    "The implementation Facade::doRun() \ninvokes the method delegate()" [shape=plaintext];
    facade -> delegate [label="calls"];
}

{ rank=same;
    owning3;
    doMapping [fixedsize="1", width="2", height="2", shape="triangle", style="filled", color="yellow"];
    Param1 [fixedsize="1", width="2", height="2", shape="diamond", style="filled", color="cyan", label="0"];
    "The method doMapping() has a parameter #0" [shape=plaintext];
    doMapping -> Param1 [label="owns"];
}

{ rank=same;
    typehint1;
    Param2 [fixedsize="1", width="2", height="2", shape="diamond", style="filled", color="cyan", label="0"];
    Person [fixedsize="1", width="2", height="2", shape="circle", style="filled", color="red"];
    "The parameter #0 is type-hinted with the class Person" [shape=plaintext];
    Param2 -> Person [label="type-hint"];
}

{ rank=same;
    typehint2;
    Param3 [fixedsize="1", width="2", height="2", shape="diamond", style="filled", color="cyan", label="0"];
    Vehicule [fixedsize="1", width="2", height="2", shape="invtriangle", style="filled", color="green"];
    "The parameter #0 is type-hinted with the interface Vehicule" [shape=plaintext];
    Param3 -> Vehicule [label="type-hint"];
}

{ rank=same;
    note;
    "All these rules were issued by a painstaking brainstorm based on Demeter's Law and S.O.L.I.D principles.
     This language is designed to easily show violations with graph theory and algorithms that's why there is some weird things.
     For example: The splitting of method signature and implementation : in fact they are coming from C++ but
     they're showing the level of abstraction. 
     There is no care if a class is abstract or not : it does not matter since I am a proponent of 'interfaces everywhere' like Java does
     for LSP concerns (and I think this principle is the best above all because it is the simplest way for introducing abstraction in source code).
     I don't care about static : in fact a static call should generate 2 edges : one to the method and one to the class. Since this is a spaghetti
     coupling with the method, I think one link is enough to show problems. Furthermore, the method is concrete and has a path to the class
     and I don't want to confuse with edges representing new instantiations.
     Parameters have no name because subclasses can change them, that's why I only keep their indices." [shape=plaintext];   
}

edge [style=invis];
vocabulary -> 
inheritance -> implementing -> extending -> declaring1  -> declaring2 -> 
owning1 -> owning2 -> depend1 -> depend2 -> depend3 -> calling -> 
owning3 -> typehint1 -> typehint2 -> note ;



};
