{% extends 'index.html.twig' %}

{% block content %}
<h1>Command line tools</h1>
<div class="row-fluid">
    <div class="span6">
        <a name="console"></a><h2>The console</h2>
        <p>
            This tool is using the Symfony/Console component, it means you have an helper 
            when you type :
            <pre>$ php console.php</pre>
        </p>
        <p>
            <pre>$ php console.php help mondrian:digraph</pre>
            ...and a listing of commands :
            <pre>$ php console.php list</pre>
        </p>
    </div>
    <div class="span6">
    </div>
</div>
<div class="row-fluid">
    <div class="span6">
        <a name="digraph"></a><h2>Make the graph</h2>
        <p>Generates a digraph on the GraphViz format (only .dot, currently other formats are not tested)</p>
        <pre>$ php console.php mondrian:digraph ~/MyMessyProject</pre>
        <p>
            This digraph is a general picture of the source. If it is too heavy or too messy, you can
            try to generate a smaller one on a deeper directory. The same way you 
            don't refactor all your app in one pass,
            you start by smaller components.
        </p>
        <p>
            This is not the tool you are looking for. Unless you have a big printer and want to impress
            your project manager and pin a big poster on the wall at office, it's not the
            real shit, at least not at the first pass.
        </p>
        <p>
            This tool is using the Symfony/Console component, it means you have an helper :
            <pre>$ php console.php help mondrian:digraph</pre>
        </p>
        <p>
            ...and a listing of commands :
            <pre>$ php console.php list</pre>
        </p>
    </div>

    <div class="span6">
        <a name="metrics"></a><h2>Metrics</h2>
        <p>Generates statistics with a short report</p>
        <pre>$ php console.php mondrian:metrics ~/MyMessyProject</pre>
        <p>
            This command prints a short report about the code.
        </p>
        <p>
            Metrics are usefull to fast evaluate what kind of project you have
            to refactor. But it is not a guide where you have to go. Of course
            a project with a 50/50 ratio in interfaces/classes can be a good thing
            but if classes are used in parameters of methods instead of interfaces,
            interfaces are not really usefull. It's easy to fake good metrics.
        </p>
        <p>
            This analyser also counts where methods are declared first in the
            inheritance tree. A good point can be that you have low count of
            method first declared in class. This can mean you can decouple your
            concrete classes (remember LSP)
        </p>
        <p>
            From my experience, it's better to have dirty code in loosely coupled
            classes than beautiful code in highly coupled classes, because your beautiful
            code does not stand a chance against the entropy of changing.
        </p>
        <p>
            Dirty code can be refactored, even in paralell process, if you have loosely
            coupling.
        </p>
        <p>
            In short : Bad coding practices has bad metrics
            but good metrics does not means good coding practices.
            That's why I didn't push too far these statistics.
        </p>
        <p>See the others tool to find out where the coupling is.</p>
    </div>
</div>
<div class="row-fluid">
    <div class="span6">
        <a name="central"></a>
        <h2>Centrality</h2>
        <p>
            This tool find the "center of the source code". More precisely
            it calculates the <a href="http://en.wikipedia.org/wiki/Centrality">centrality</a>
            of the digraph with the <a href="http://en.wikipedia.org/wiki/Eigenvector">eigenvectors</a>
            of the
            <a href="http://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>.
            With this you can determinate what component is critical
            and what component could be refactored later.
        </p>
        <p>This tool helps you to find two effects on some components:</p>
        <h3>The ripple effect</h3>
        <pre>$ php console.php mondrian:centrality:used ~/MyMessyProject</pre>
        <p>
            One component (class, parameter, method...) can be highly used accross
            the source code. Each time there is a change in this component, chances
            are you need to change many other components directly depending on it
            and so on. That's the ripple. With the "used" algorithm you can view
            what component is time consuming and can lead to many merge conflicts in
            Git.
        </p>
        <h3>The bottleneck effect</h3>
        <pre>$ php console.php mondrian:centrality:depend ~/MyMessyProject</pre>
        <p>
            Do you remember this project where everytime you made a change somewhere,
            THAT class need to be modified too ? The "depend" algorithm finds this
            kind of problems. It searchs for the depencencies, but not only direct
            dependencies but also the combination of dependencies accross all the
            vertices of a digraph. My recommandation : abstract this component first :
            make multiple interfaces, explode it with strategy pattern, decorator,
            CoR etc... All bugs are "drown" to this component like a blackhole.
        </p>
    </div>
    <div class="span6">
        <a name="spaghet"></a><h2>Spaghetti coupling</h2>
        <p>
            SpaghettiCoupling is an analyser which finds coupling between implementations,
            I mean between public methods without abstraction.
        </p>
        <pre>$ php console.php mondrian:spaghetti ~/MyProject</pre>
        <p>
            Example :<br/>
            In the implementation of the method A::doThing(), there is a call to
            the method B::getThing().
        </p>
        <p>
            If B::getThing() is declared in B, the two methods are coupled. One can
            find a directed path between these implementation vertices.
        </p>
        <p>
            If B::getThing() is an implementation of C::getThing() declared in the C interface
            from which B inherits, there is no coupling because, A::doThing() is linked
            to C::getThing(), therefore no directed path. Liskov principle is safe.
        </p>
        <p>
            The first case is what I call "modern spaghetti code" :
            yes you haZ objects and classes
            but you are not S.O.L.I.D. You rely on concrete class, not abstraction,
            not "contract" (interface). Your classes are just a collection of functions
            with an attached data structure, not an abstract idea.
        </p>
        <p>
            Therefore, each time you make a modification in B::getThing(), you can
            break its contract and break something in A::doThing(). Worst, A has
            a link to B, therefore A can call anything in B. Classes get fat, instable,
            and you fear each time you move a semi-colon.
        </p>
    </div>
</div>
<div class="row-fluid">
    <div class="span6">
        <a name="hidden"></a><h2>Hidden coupling</h2>
        <p>
            This is an analyser which checks and finds hidden coupling
            between types.
        </p>
        <pre>$ php console.php mondrian:hidden ~/MyProject</pre>
        <p>
            This analyser searches for method calls. Everytime there is a call of
            a method against an object ( $obj->getThing() ), it means an edge from
            an implementation vertex where the call is to a method signature vertex.
        </p>
        <p>
            Since "$obj" does not come from nowhere, its type (class or interface)
            must be known by the class owning the implementation vertex.
            In other words :
            If there is an edge from an implementation to a method, there must be
            at least one another directed path between these two vertices
            (through the class vertex, through a parameter vertex, superclass etc...)
            If you can't figure why, I recommand you to read the digraph language
            I've defined in this intent.
        </p>
        <p>
            If there is none, *maybe* it means a hidden coupling. I add the "maybe"
            because, it's hard to find the type of "$obj" in soft-typed language like
            PHP. That's why there can be false positive. But it's easier to check
            false positives than to search through all over the php files to find
            that kind of weakness in the code.
        </p>
    </div>
    <div class="span6">
        <a name="cyclic"></a><h2>Cyclic coupling</h2>
        <p>
            Can be renamed : How to avoid cyclic dependencies ? When yo have a cycle in
            source code, you are really screwd because it's very difficult to know where to
            break it. This tool finds
            <a href="http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">cycles between vertices</a>
            in the digraph.
        </p>
        <pre>$ php console.php mondrian:scc ~/MyProject</pre>
        <p>
            This command uses the Tarjan algorithm for finding Strongly Connected Components.
        </p>
        <p>
            This command (and the others too) needs some customization of the code. Since
            PHP is not strongly typed, it is somewhat difficult to find which method is called
            in an implementation. For that, there is an annotation (a comment) to put
            in your code in the header of the method where the calling is done :
            <pre>
/**
 * @mondrian ignoreCallTo MyProject\MyClass::someMethod
 */</pre>
            It means the current implementation will not be linked with the specified method.<br/>
            See a sample in
            <a href="https://github.com/Trismegiste/Mondrian/blob/master/Tests/Fixtures/Project/FilterIgnoreCallTo.php#L45">unit tests</a>
        </p>
    </div>
</div>
{% endblock %}