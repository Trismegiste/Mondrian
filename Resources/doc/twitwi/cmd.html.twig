{% extends 'index.html.twig' %}

{% block content %}
<h1>Command line tools</h1>
<div class="row-fluid">
    <div class="span6">
        <a name="console"></a><h2>The console</h2>
        <p>
            This tool is using the Symfony/Console component, it means you have an helper 
            when you type :
            <pre>$ php console.php</pre>
        </p>
        <p>
            You have an helper on a command
            <pre>$ php console.php help mondrian:digraph</pre>
        </p>
        <p>
            And a listing of commands :
            <pre>$ php console.php list</pre>
        </p>
        <p>
            All commands which generate digraph need a mandatory argument for
            the directory to recursively scan and parse all PHP files.
        </p>
        <p>
            The second argument is the basename of the generated file.<br/>
            Default value is "report"
        </p>
        <p>
            You can optionally ignore some directories with the option --ignore<br/>
            Default values are : "Tests" and "vendor" to avoid scanning for vendor
            and Tests.
        </p>
        <p>
            The second option is the format for the generated report. Default value is "dot" 
            (GraphViz format)
        </p>
    </div>
    <div class="span6">
        <a name="soft"></a><h2>PHP has a soft touch</h2>
        <p>
            As you know, PHP is (very) soft-typed. I don't want to start a debate but
            this kind of static analysis tool has a disavantage with PHP : it is hard to
            "track" the type of a given variable. I've tried some simplistic approach
            but in the end, when you have a line like :
            <pre>call_user_func($this->$$objName, $methodName);</pre>
            You have a good chance to mistake on the type. That's why, I have add
            some annotations to put in your code to remove bad link and add some other.
        </p>
        <p>
            Currently, there is an annotation (a comment) to put
            in your code in the header of the method where a calling is done :
            <pre>
/**
 * @mondrian ignoreCallTo MyProject\MyClass::someMethod
 */</pre>
            It means the current implementation will not be linked with the specified method.<br/>
            See a sample in
            <a href="https://github.com/Trismegiste/Mondrian/blob/master/Tests/Fixtures/Project/FilterIgnoreCallTo.php#L45">unit tests</a>
        </p>

    </div>
</div>
<div class="row-fluid">
    <div class="span6">
        <a name="digraph"></a><h2>Make the graph</h2>
        <p>Generates a digraph on the GraphViz format (only .dot, currently other formats are not tested)</p>
        <pre>$ php console.php mondrian:digraph ~/MyMessyProject</pre>
        <p>
            This digraph is a general picture of the source. If it is too heavy or too messy, you can
            try to generate a smaller one on a deeper directory. The same way you 
            don't refactor all your app in one pass, you start by smaller components.
        </p>
        <p>
            After the generation, this command prints some useful metrics. They
            are useful to fast evaluate what kind of project you have
            to refactor. But it is not a guide where you have to go. Of course
            a project with a 50/50 ratio in interfaces/classes can be a good thing
            but if classes are used in parameters of methods instead of interfaces,
            interfaces are not really usefull. It's easy to fake good metrics.
        </p>
        <p>
            This analyser also counts where methods are declared first in the
            inheritance tree. A good point can be that you have low count of
            method first declared in class. This can mean you can decouple your
            concrete classes (remember LSP)
        </p>
    </div>
    <div class="span6">
        <a name="central"></a>
        <h2>Centrality</h2>
        <p>
            This tool find the "center of the source code". More precisely
            it calculates the <a href="http://en.wikipedia.org/wiki/Centrality">centrality</a>
            of the digraph with the <a href="http://en.wikipedia.org/wiki/Eigenvector">eigenvectors</a>
            of the
            <a href="http://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>.
            With this you can determinate what component is critical
            and what component could be refactored later.
        </p>
        <p>This tool helps you to find two effects on some components:</p>
        <h3>The ripple effect</h3>
        <pre>$ php console.php mondrian:centrality:used ~/MyMessyProject</pre>
        <p>
            One component (class, parameter, method...) can be highly used accross
            the source code. Each time there is a change in this component, chances
            are you need to change many other components directly depending on it
            and so on. That's the ripple. With the "used" algorithm you can view
            what component is time consuming and can lead to many merge conflicts in
            Git.
        </p>
        <h3>The bottleneck effect</h3>
        <pre>$ php console.php mondrian:centrality:depend ~/MyMessyProject</pre>
        <p>
            Do you remember this project where everytime you made a change somewhere,
            THAT class need to be modified too ? The "depend" algorithm finds this
            kind of problems. It searchs for the depencencies, but not only direct
            dependencies but also the combination of dependencies accross all the
            vertices of a digraph. My recommandation : abstract this component first :
            make multiple interfaces, explode it with strategy pattern, decorator,
            CoR etc... All bugs are "drown" to this component like a blackhole.
        </p>
    </div>
</div>
<div class="row-fluid">
    <div class="span6">
        <a name="spaghet"></a><h2>Spaghetti coupling</h2>
        <p>
            SpaghettiCoupling is an analyser which finds coupling between implementations,
            I mean between public methods without abstraction.
        </p>
        <pre>$ php console.php mondrian:spaghetti ~/MyProject</pre>
        <p>
            Example :<br/>
            In the implementation of the method A::doThing(), there is a call to
            the method B::getThing().
        </p>
        <p>
            If B::getThing() is declared in B, the two methods are coupled. One can
            find a directed path between these implementation vertices.
        </p>
        <p>
            If B::getThing() is an implementation of C::getThing() declared in the C interface
            from which B inherits, there is no coupling because, A::doThing() is linked
            to C::getThing(), therefore no directed path. Liskov principle is safe.
        </p>
        <p>
            The first case is what I call "modern spaghetti code" :
            yes you haZ objects and classes
            but you are not S.O.L.I.D. You rely on concrete class, not abstraction,
            not "contract" (interface). Your classes are just a collection of functions
            with an attached data structure, not an abstract idea.
        </p>
        <p>
            Therefore, each time you make a modification in B::getThing(), you can
            break its contract and break something in A::doThing(). Worst, A has
            a link to B, therefore A can call anything in B. Classes get fat, instable,
            and you fear each time you move a semi-colon.
        </p>
    </div>
    <div class="span6">
        <a name="hidden"></a><h2>Hidden coupling</h2>
        <p>
            This is an analyser which checks and finds hidden coupling
            between types.
        </p>
        <pre>$ php console.php mondrian:hidden ~/MyProject</pre>
        <p>
            This analyser searches for method calls. Everytime there is a call of
            a method against an object ( $obj->getThing() ), it means an edge from
            an implementation vertex where the call is to a method signature vertex.
        </p>
        <p>
            Since "$obj" does not come from nowhere, its type (class or interface)
            must be known by the class owning the implementation vertex.
            In other words :
            If there is an edge from an implementation to a method, there must be
            at least one another directed path between these two vertices
            (through the class vertex, through a parameter vertex, superclass etc...)
            If you can't figure why, I recommand you to read the digraph language
            I've defined in this intent.
        </p>
        <p>
            If there is none, *maybe* it means a hidden coupling. I add the "maybe"
            because, it's hard to find the type of "$obj" in soft-typed language like
            PHP. That's why there can be false positive. But it's easier to check
            false positives than to search through all over the php files to find
            that kind of weakness in the code.
        </p>
    </div>
    <div class="span6">
        <a name="cyclic"></a><h2>Cyclic coupling</h2>
        <p>
            Can be renamed : How to avoid cyclic dependencies ? When yo have a cycle in
            source code, you are really screwd because it's very difficult to know where to
            break it. This tool finds
            <a href="http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">cycles between vertices</a>
            in the digraph.
        </p>
        <pre>$ php console.php mondrian:scc ~/MyProject</pre>
        <p>
            This command uses the Tarjan algorithm for finding Strongly Connected Components.
        </p>
    </div>
</div>
{% endblock %}